#!/usr/bin/env python3
"""
REMU Configuration Generator
Reads .config and generates src/generated/config.rs with proper constants
"""

import re
import sys
import os
from pathlib import Path

# Default configuration values for known keys
DEFAULT_CONFIGS = {
    "TRACE": "n",
    "TRACE_START": "0",
    "TRACE_END": "0",
    "ITRACE": "n",
    "ITRACE_COND": '"false"',
    "ITRACE_RINGBUF": "0",
    "MTRACE": "n",
    "MTRACE_COND": '"false"',
    "MTRACE_RINGBUF": "0",
    "FTRACE": "n",
    "FTRACE_COND": '"false"',
    "FTRACE_BUF": "0",
    "DTRACE": "n",
    "DTRACE_COND": '"false"',
    "DTRACE_RINGBUF": "0",
    "TRACE_INTR": "n",
    "TRACE_MMU": "n",
    "TRACE_PLIC": "n",
    "TRACE_ECALL": "n",
    "DEVICE": "n",
    "HAS_VGA": "n",
    "VGA_SHOW_SCREEN": "n",
    "VGA_WIDTH": "400",
    "VGA_HEIGHT": "300",
    "HAS_KEYBOARD": "n",
    "I8042_DATA_MMIO": "0",
    "HAS_SERIAL": "n",
    "SERIAL_MMIO": "0",
    "HAS_TIMER": "n",
    "RTC_MMIO": "0",
    "HAS_AUDIO": "n",
    "HAS_DISK": "n",
    "HAS_CLINT": "n",
    "HAS_PLIC": "n",
    "FB_ADDR": "0",
    "VGA_CTL_MMIO": "0",
    "SB_ADDR": "0",
    "SB_SIZE": "0",
    "AUDIO_CTL_MMIO": "0",
    "DISK_CTL_MMIO": "0",
    "TIMER_GETTIMEOFDAY": "n",
    "TIMER_CLOCK_GETTIME": "n",
    "RT_CHECK": "n",
    "WATCHPOINT": "n",
    "EVAL_DEBUG": "n",
}

def parse_config(config_file):
    """Parse .config file and return dictionary of config values"""
    configs = DEFAULT_CONFIGS.copy()
    
    if not os.path.exists(config_file):
        print(f"Warning: {config_file} not found")
        return configs

    with open(config_file, 'r') as f:
        for line in f:
            line = line.strip()
            
            # Handle "# CONFIG_XXX is not set"
            if line.startswith("# CONFIG_") and line.endswith(" is not set"):
                key = line[9:-11]
                configs[key] = "n"
                continue
            
            # Skip comments and empty lines
            if not line or line.startswith('#'):
                continue
            
            # Match CONFIG_XXX=value or CONFIG_XXX=y
            if '=' in line:
                key, value = line.split('=', 1)
                
                # Strip CONFIG_ prefix if present
                if key.startswith('CONFIG_'):
                    key = key[7:]
                
                # Remove quotes from string values for processing
                value = value.strip()
                configs[key] = value
    
    return configs

def generate_rust_code(configs):
    """Generate Rust code from parsed config"""
    
    lines = []
    lines.append("// Auto-generated from .config - DO NOT EDIT MANUALLY")
    lines.append("// Generated by scripts/gen_config.py")
    lines.append("")
    lines.append("#![allow(dead_code)]")
    lines.append("")
    
    # Generate constants
    for key, value in sorted(configs.items()):
        # Determine value and type
        # Remove quotes for analysis
        clean_value = value.strip('"')
        
        # Upper case key for Rust constant convention
        const_key = key.upper()
        
        if clean_value == 'y':
            rust_type = 'bool'
            rust_val = 'true'
        elif clean_value == 'n':
            rust_type = 'bool'
            rust_val = 'false'
        elif value.startswith('0x') or value.startswith('0X'):
            # Hex number
            # Special case for addresses/sizes that might be u64
            if const_key in ['TRACE_START', 'TRACE_END', 'FTRACE_BUF']:
                rust_type = 'u64'
            else:
                rust_type = 'u32'
            rust_val = value
        elif clean_value.isdigit():
            # Decimal number
            if const_key in ['TRACE_START', 'TRACE_END', 'FTRACE_BUF']:
                rust_type = 'u64'
            else:
                rust_type = 'u32'
            rust_val = value
        else:
            # String
            rust_type = '&str'
            if not value.startswith('"'):
                rust_val = f'"{value}"'
            else:
                rust_val = value
        
        # Generate constant
        lines.append(f'pub const {const_key}: {rust_type} = {rust_val};')
    
    return '\n'.join(lines) + '\n'

def main():
    # Paths
    # Assuming script is in scripts/ and run from project root or scripts/
    script_dir = Path(__file__).parent.resolve()
    remu_home = script_dir.parent
    
    config_file = remu_home / '.config'
    # Ensure src/generated exists
    output_dir = remu_home / 'src' / 'generated'
    output_dir.mkdir(parents=True, exist_ok=True)
    
    output_file = output_dir / 'config.rs'
    
    print(f"Reading config from: {config_file}")
    
    # Parse config
    configs = parse_config(config_file)
    
    # Generate Rust code
    rust_code = generate_rust_code(configs)
    
    # Write output
    with open(output_file, 'w') as f:
        f.write(rust_code)
    
    print(f"Generated {output_file}")
    print(f"  {len(configs)} configuration options")

if __name__ == '__main__':
    main()
